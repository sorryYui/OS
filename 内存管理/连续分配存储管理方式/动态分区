1.动态分区分配原理
  系统初始时只有一个空闲区，当进程申请空间时，由系统根据进程需要的空间大小划分出一片空闲区分配给进程。
  系统运行一段时间之后，内存的空闲区可能散布在不连续的区域。系统维护一个记录当前空闲分区情况的数据结构。
  当进程请求内存时，系统从所有空闲空间找到大小适合的空闲分区进行分配。系统中分区的大小和数量都是变化的，空闲区的大小和数量也是变化的。
2.动态分区分配中的数据结构
  1.空闲分区表
    系统在空闲分区表中为每一个空闲分区建立一个表项，每一个表项中包括分区编号，分区大小和分区起始地址。
    struct
    {
      int num; //分区编号
      int length; // 分区大小
      int addr; //分区起始地址
    }FreeMem_block[N] //N为最大分区数量
  2.空闲分区链
    使用双向链表表示空闲分区集合，节点为空闲分区。
    struct FreeMem
    {
      int length; //空闲分区大小
      int addr; //空闲分区起始地址
      TFreeMem * prev, * next; //双向链表
    }
3.动态分区算法
  当进程需要内存空间时，OS通过执行动态分区分配算法为进程分配空闲分区。
  1.首次适应算法(FF)
    要求空闲分区链以地址递增的顺序链接。在进行内存分配时，从链首开始顺序寻找，直到找到第一个适合进程大小要求的空闲分区。
    然后，从该分区中划出一块内存空间分配个进程，余下的空闲分区仍然留在空闲链中。
    缺点：低地址容易留下小空闲分区，导致分配的时间变长，并且留下一些难以利用的小空闲分区。
  2.循环首次适应算法(NF)
    在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直到找到第一个适合进程大小的空闲分区。
    然后。从中划出一块与请求的大小相等的内存空间分配给进程。
    缺点：系统可能缺乏大空间。
  3.最佳适应算法(BF)
    该算法每次为进程分配内存时，总是把大小与进程所请求的内存空间大小最接近的空闲分区分配给进程。
    为了加速寻找，要求所有的空闲分区按分区大小递增排列成为一个空闲分区链，这样第一次寻找到的空闲分区时最适合的。
    优点：查找速度快。
    缺点：产生难以运用的小空闲分区。
    
